\documentclass[10pt]{article}

%Math
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{stmaryrd} %f\UTF{00FC}r Blitz!

%PageStyle
\usepackage[ngerman]{babel} % deutsche Silbentrennung
\usepackage[utf8]{inputenc} 
\usepackage{fancyhdr, graphicx}
\usepackage[scaled=0.92]{helvet}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage[a4paper,top=2cm]{geometry}
\setlength{\textwidth}{17cm}
\setlength{\oddsidemargin}{-0.5cm}

% Shortcommands
\newcommand{\Bold}[1]{\textbf{#1}} %Boldface
\newcommand{\Kursiv}[1]{\textit{#1}} %Italic
\newcommand{\T}[1]{\text{#1}} %Textmode
\newcommand{\Nicht}[1]{\T{\sout{$ #1 $}}} %Streicht Shit durch

%Arrows
\newcommand{\lra}{\leftrightarrow} 
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lral}{\longleftrightarrow}
\newcommand{\ral}{\longrightarrow}
\newcommand{\lal}{\longleftarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\Lral}{\Longleftrightarrow}
\newcommand{\Ral}{\Longrightarrow}
\newcommand{\Lal}{\Longleftarrow}

% Code listenings
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white,font=bf}


\lstdefinestyle{sqlNoTitle}{
   language=SQL,
   basicstyle=\footnotesize\ttfamily, % Standardschrift
   backgroundcolor=\color[RGB]{230,230,230}, % Hintergrundfarbe
   numbers=left,               % Ort der Zeilennummern
   numberstyle=\tiny,          % Stil der Zeilennummern
   stepnumber=1,               % Abstand zwischen den Zeilennummern
   numbersep=5pt,              % Abstand der Nummern zum Text
   tabsize=2,                  % Groesse von Tabs
   extendedchars=true,         %
   breaklines=true,            % Zeilen werden Umgebrochen
   frame=trbl,                 % Rahmen
   stringstyle=\color[RGB]{42,0,255} \ttfamily, % Farbe der String
   keywordstyle=\color[RGB]{127,0,85} \ttfamily, % Farbe der Keywords
   commentstyle=\color[RGB]{63,127,95} \ttfamily, % Farbe des Kommentars
   showspaces=false,           % Leerzeichen anzeigen ?
   showtabs=false,             % Tabs anzeigen ?
   xleftmargin=17pt,
   framexleftmargin=17pt,
   framexrightmargin=5pt,
   framexbottommargin=5pt,
   framextopmargin=5pt,
   showstringspaces=false,     % Leerzeichen in Strings anzeigen ?
}


\lstdefinestyle{sql}{
   style=sqlNoTitle,
   title=SQL-Query
}

\lstdefinestyle{queryexecutionplan}{
  basicstyle=\footnotesize\ttfamily, % Standardschrift
  backgroundcolor=\color[RGB]{240,255,240}, % Hintergrundfarbe
  frame=trbl,                 % Rahmen
  title=Ausführungsplan
}

\lstdefinestyle{queryexecutionplanSmall}{
  style=queryexecutionplan,
  basicstyle=\scriptsize\ttfamily, % Standardschrift
}

%Config
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{15.2pt}

%Metadata
\fancyfoot[C]{}
\title{
	\vspace{4cm}
	\huge{Datenbank-Architektur für Fortgeschrittene}\\
	\vspace{0.2cm}
	\Large{Ausarbeitung 1: Anfrageverarbeitung}\\
}
\author{Thomas Baumann / Egemen Kaba}
\date{01.05.2013}

% hier beginnt das Dokument
\begin{document}

% Titelbild
\maketitle
\thispagestyle{fancy}

\newpage

% Inhaltsverzeichnis
\pagenumbering{Roman}
\tableofcontents	  	


\newpage
\setcounter{page}{1}
\pagenumbering{arabic}

% Inhalt Start

\section{Einleitung}
\subsection{Sonderzächön}
sind mägö cöäl! Hallo "Max" und "Moritz"!
\section{Vorbereitung}
\subsection{Einrichten Datenbasis}
\begin{lstlisting}[style=sql]
CREATE TABLE regions
AS SELECT *
  FROM dbarc00.regions;
  
CREATE TABLE nations
AS SELECT *
  FROM dbarc00.nations;

CREATE TABLE parts
AS SELECT *
  FROM dbarc00.parts;
  
CREATE TABLE customers
AS SELECT *
  FROM dbarc00.customers;

CREATE TABLE suppliers
AS SELECT *
  FROM dbarc00.suppliers;

CREATE TABLE orders
AS SELECT *
  FROM dbarc00.orders;

CREATE TABLE partsupps
AS SELECT *
  FROM dbarc00.partsupps;

CREATE TABLE lineitems
AS SELECT *
  FROM dbarc00.lineitems;
\end{lstlisting}
\subsection{Tabellenstatistik}
\begin{lstlisting}[style=sql]
SELECT segment_name, bytes, blocks, extents
FROM user_segments;

SELECT table_name, num_rows
FROM user_tab_statistics;
\end{lstlisting}
Folgende Tabellenstatistik haben wir mit den oben genannten Querys erhoben.

\begin{tabular}{l||r|r|r|r}
  Tabelle & Anzahl Zeilen & Grösse in Bytes & Anzahl Blöcke & Anzahl Extents \\ \hline
  \hline
  CUSTOMERS & 150'000 & 29'360'128 & 3'584 & 43 \\ \hline
  LINEITEMS & 6'001'215 & 897'581'056 & 109'568 & 178 \\ \hline
  NATIONS & 25 & 65'536 & 8 & 1 \\ \hline
  ORDERS & 1'500'000 & 201'326'592 & 24'576 & 95 \\ \hline
  PARTS & 200'000 & 32'505'856 & 3'968 & 46 \\ \hline
  PARTSUPPS & 800'000 & 142'606'336 & 17'408 & 88 \\ \hline
  REGIONS & 5 & 65'536 & 8 & 1 \\ \hline
  SUPPLIERS & 10'000 & 2'097'152 & 256 & 17 \\
\end{tabular}	

\section{Ausführungsplan}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM parts;

SELECT plan_table_output
FROM TABLE(DBMS_XPLAN.DISPLAY('plan_table',null,'serial'));
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |   190K|    26M|  1051   (1)| 00:00:13 |
|   1 |  TABLE ACCESS FULL| PARTS |   190K|    26M|  1051   (1)| 00:00:13 |
---------------------------------------------------------------------------
\end{lstlisting}
Die Tabelle zeigt die einzelnen Schritte des Ausführungsplanes, welche der 
Optimizer erstellt hat, mit den jeweilig zurückgegebenen Anzahl Zeilen, deren 
Grösse, die Kosten und Zeit für die Teilschritte. Man kann sich den 
Ausführungsplan als Baum vorstellen. Die Einrückungen stellen die Knotentiefe dar.

Für die nächsten Aufgaben verwenden wir das obenstehende Statement. Wir 
haben jeweils das Query ausgetauscht um den Ausführungsplan zu erhalten.

\section{Versuche ohne Index}
\subsection{Projektion}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1579K|   209M|  6612   (1)| 00:01:20 |
|   1 |  TABLE ACCESS FULL| ORDERS |  1579K|   209M|  6612   (1)| 00:01:20 |
---------------------------------------------------------------------------- 
\end{lstlisting}   
\textbf{Reflexion} \newline
Da alle Zeilen und Spalten der Tabelle ausgelesen werden müssen wird hier ein
Full Table Scan durchgeführt. Aus der Statistik geht hervor, dass diese Tabelle
1579K Zeilen umfasst, 209MB gross ist und ein Full Table Scan 6612 CPU-Indexpunkte
beansprucht.

\begin{lstlisting}[style=sql]
SELECT o_clerk
FROM orders;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1579K|    25M|  6608   (1)| 00:01:20 |
|   1 |  TABLE ACCESS FULL| ORDERS |  1579K|    25M|  6608   (1)| 00:01:20 |
---------------------------------------------------------------------------- 
\end{lstlisting}   
\textbf{Reflexion} \newline
Es werden wiederum alle Zeile, jedoch nicht alle Spalten ausgelesen.
Exakt läuft es so ab, dass zuerst die ganze Tabelle gelesen wird und danach die nicht
benötigten Spalten herausgefiltert werden.
Das verringert die Anzahl Daten, die gespeichert werden müssen, drastisch von 209MB auf 25MB.
Zudem ist die benötigte CPU-Leistung minimal weniger, aufgrund der Reduktion des
zu verwaltenden Speichers.

\begin{lstlisting}[style=sql]
SELECT DISTINCT o_clerk
FROM orders;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
-------------------------------------------------------------------------------------
| Id  | Operation          | Name   | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |        |  1579K|    25M|       | 15333   (1)| 00:03:04 |
|   1 |  HASH UNIQUE       |        |  1579K|    25M|    36M| 15333   (1)| 00:03:04 |
|   2 |   TABLE ACCESS FULL| ORDERS |  1579K|    25M|       |  6608   (1)| 00:01:20 |
-------------------------------------------------------------------------------------
\end{lstlisting} 
\textbf{Reflexion} \newline
Wie beim vorherigen Befehl werden alle Zeilen einer bestimmten Spalte ausgelesen,
was wiederum einen Zugriff auf die gesamte Tabelle nötig macht.
Zusätzlich zu diesem Aufwand müssen vorangehend alle doppelten Einträge herausgefiltert werden,
was die massiv angestiegenen CPU-Kosten bei Id 0 und 1 erklärt.
Die zusätzliche Operation mit der Id 1 dient dazu, die doppelten Werte herauszufiltern.
Für die Speicherung von Zwischenresultaten wird dabei temporärer Speicher beansprucht.

\subsection{Selektion}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6603   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6603   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Es soll nur ein Tupel ausgewählt werden (Spalte ist Primary Key), da jedoch 
kein index besteht, ist nicht bekannt, wo der Eintrag liegt und zusätzlich 
kann nach dem ersten Fund nicht abgebrochen werden. Deshalb muss wieder ein 
Full Table Scan durchgeführt werden. Durch die Bedingung wird viel weniger 
Hauptspeicher benötigt.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 OR o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6631   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6631   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444 OR "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Im Vergleich zum vorherigen Query sind nur die Kosten minimal gestiegen, dies 
ist auf die zweite Bedingung zurück zu führen.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   158 | 21962 |  6612   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   158 | 21962 |  6612   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Durch die AND-verknüpfung muss die zweite Bedingung nur überprüft werden, wenn 
die Erste erfüllt ist. So sind alle Werte, ausser die Zeit gesunken.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey*2 = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   158 | 21962 |  6616   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   158 | 21962 |  6616   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"*2=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Die Werte sind alle genau gleich, wie beim vorherigen Query, obwohl eigentlich 
eine zusätzliche Operation pro Zeile notwendig ist ($o\_orderkey*2$). Wir 
vermuten, dass dieses Query vor der Abfrage optimiert wird, besser gesagt, die
Berechnung wird vereinfacht, so muss nur eine Operation ausgeführt werden:
\begin{lstlisting}[style=sqlNoTitle]
o_orderkey = 22222 AND o_clerk = 'Clerk#000000286'
\end{lstlisting}

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 111111 AND 222222;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6603   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6603   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY">=111111 AND "O_ORDERKEY"<=222222)
\end{lstlisting}
\textbf{Reflexion} \newline

Die Selektion 
\begin{lstlisting}[style=sqlNoTitle]
column BETWEEN x AND y 
\end{lstlisting}
wird durch folgendes 
\begin{lstlisting}[style=sqlNoTitle]
column >= x AND column <= y 
\end{lstlisting}
ersetzt. Im Vergleich zum Vorherigen, sind die Anzahl Zeilen und die 
Speicherbenutzung gestiegen, dies weil mehr Tupel selektiert werden. Hingegen 
sind die Kosten gesunken, dies ist aus unserer Sicht dadurch zu Begründen, da 
bei beiden Vergleichen, die gleiche Spalte verwendet wird.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 44444 AND 55555
AND o_clerk BETWEEN 'Clerk#000000130' AND 'Clerk#000000139';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |    10 |  1390 |  6613   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |    10 |  1390 |  6613   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY">=44444 AND "O_ORDERKEY"<=55555 AND 
              "O_CLERK">='Clerk#000000130' AND "O_CLERK"<='Clerk#000000139')
\end{lstlisting}
\textbf{Reflexion} \newline
Auch hier wurden die BETWEEN wieder mit grösser gleich und kleiner gleich ersetzt. 
Die Resultierende Anzahl Tupel und der benötigte Speicher sind nochmals gesunken. 
Wohin gegen die Kosten gestiegen sind, da bis zu vier Vergleiche notwendig sind.

\subsection{Join}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders, customers
WHERE o_custkey = c_custkey
AND o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  1 |  HASH JOIN         |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  2 |   TABLE ACCESS FULL| ORDERS    |    25 |  2775 |  6602   (1)| 00:01:20 |
|   3 |   TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|   951   (1)| 00:00:12 |
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------                                                                 
   1 - access("O_CUSTKEY"="C_CUSTKEY")
   2 - filter("O_ORDERKEY"<100)
\end{lstlisting}  
\textbf{Varianten}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE o_orderkey < 100
AND c_custkey = o_custkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |    25 |  6750 |  7556   (1)| 00:01:31 |
|*  1 |  HASH JOIN         |           |    25 |  6750 |  7556   (1)| 00:01:31 |
|*  2 |   TABLE ACCESS FULL| ORDERS    |    25 |  2775 |  6604   (1)| 00:01:20 |
|   3 |   TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|   951   (1)| 00:00:12 |
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("C_CUSTKEY"="O_CUSTKEY")
   2 - filter("O_ORDERKEY"<100)
\end{lstlisting}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE c_custkey = o_custkey
AND o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  1 |  HASH JOIN         |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  2 |   TABLE ACCESS FULL| ORDERS    |    25 |  2775 |  6602   (1)| 00:01:20 |
|   3 |   TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|   951   (1)| 00:00:12 |
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("C_CUSTKEY"="O_CUSTKEY")
   2 - filter("O_ORDERKEY"<100)
\end{lstlisting}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE o_custkey = c_custkey
AND o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  1 |  HASH JOIN         |           |    25 |  6750 |  7555   (1)| 00:01:31 |
|*  2 |   TABLE ACCESS FULL| ORDERS    |    25 |  2775 |  6602   (1)| 00:01:20 |
|   3 |   TABLE ACCESS FULL| CUSTOMERS |   150K|    22M|   951   (1)| 00:00:12 |
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("O_CUSTKEY"="C_CUSTKEY")
   2 - filter("O_ORDERKEY"<100)
\end{lstlisting}
\textbf{Reflexion} \newline
Der Optimizer wählt bei allen Varianten automatisch die Perfomanteste aus. Somit lautet die Antwort auf die Frage: Nein.
Im Folgenden werden einige Gründe aufgeführt:
Es wird ein Fremdschlüssel von orders und der Primärschlüssel von customers verglichen.
Dadurch können in beiden Tabellen nicht benötigte Tuppel vorab herausgefiltert werden.
Dies hat den Vorteil, dass weniger Speicher und CPU für weitere Operationen benötigt werden.
Danach werden die restlichen Tuppel der Tabelle orders mit der zweiten Bedingung herausgefiltert.
Wenn nun die minimalst mögliche Anzahl Tuppel erreicht worden sind, wird auf die Tabelle
customers zugegriffen und mit der Tabelle orders gejoint.

\section{Versuche mit Index}
\begin{lstlisting}[style=sql]
SELECT segment_name, bytes
FROM user_segments;
\end{lstlisting}


\begin{tabular}{l||r|r|r}
  Index & Grösse in Bytes & Tabellen Grösse in Bytes & Anteil von \\ 
  & & &  Index an Tabelle \\ \hline
  \hline
  O\_ORDERKEY\_IX & 30'408'704 & 201'326'592 & 15.10\%  \\ \hline
  O\_CLERK\_IX & 48'234'496 & 201'326'592 & 23.96\% \\ 
\end{tabular}

\subsection{Projektion}
\begin{lstlisting}[style=sql]
SELECT DISTINCT o_clerk
FROM orders;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------
| Id  | Operation             | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |            |  1000 | 16000 |  1622   (5)| 00:00:20 |
|   1 |  HASH UNIQUE          |            |  1000 | 16000 |  1622   (5)| 00:00:20 |
|   2 |   INDEX FAST FULL SCAN| O_CLERK_IX |  1500K|    22M|  1553   (1)| 00:00:19 |
------------------------------------------------------------------------------------
\end{lstlisting}
\textbf{Reflexion} \newline
Statt dem Full Table Access wird jetzt ein Index Range Scan angewendet. Dadurch können die benötigten Einträge wesentlich schneller gefunden werden. Konkret werden im Vergleich zum Versuch ohne Index über weniger Reihen iteriert, weniger Platz im Memory sowie kein temporärer Speicher mehr benötigt, weniger CPU beansprucht und das Query wird deutlich schneller abgearbeitet.

\subsection{Selektion}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------------------------
| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |               |     1 |   111 |     4   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| ORDERS        |     1 |   111 |     4   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | O_ORDERKEY_IX |     1 |       |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Hier wird selektiv mittels eines Index Range Scan gesucht. Es liefert die Position auf der Disk mittels der ROWID. Anhand dieser ROWID wird wiederum direkt auf die Tabelle zugegriffen.

\begin{lstlisting}[style=sql]
SELECT /*+ FULL(orders) */ *
FROM orders
WHERE o_orderkey = 44444;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     1 |   111 |  6602   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |     1 |   111 |  6602   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Der Hint erzwingt einen Full Table Access, was zu einen massiven Anstieg des Ressourcenverbrauchs führt.
Der Index wird dabei nicht benutzt.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 OR o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplanSmall]
--------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |               |  1501 |   162K|   336   (0)| 00:00:05 |
|   1 |  TABLE ACCESS BY INDEX ROWID     | ORDERS        |  1501 |   162K|   336   (0)| 00:00:05 |
|   2 |   BITMAP CONVERSION TO ROWIDS    |               |       |       |            |          |
|   3 |    BITMAP OR                     |               |       |       |            |          |
|   4 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|*  5 |      INDEX RANGE SCAN            | O_CLERK_IX    |       |       |     8   (0)| 00:00:01 |
|   6 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|*  7 |      INDEX RANGE SCAN            | O_ORDERKEY_IX |       |       |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   5 - access("O_CLERK"='Clerk#000000286')
   7 - access("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Durch den Zugriff auf Indizes wird auch hier direkt auf die benötigten Tuppel zugegriffen.
Statt einer werden zwei Indizes verwendet, da die OR-Verknüpfung den Zugriff auf zwei indexierte Spalten verlangt.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------------------------
| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |               |     1 |   111 |     4   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| ORDERS        |     1 |   111 |     4   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | O_ORDERKEY_IX |     1 |       |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_CLERK"='Clerk#000000286')
   2 - access("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Bevor hier der Index Range Scan auf die Spalte orderkey angewendet wird, werden die Einträge nach der Spalte clerk gefiltert. Dies geschieht deswegen, weil ein Tuppel Kriterien in zwei Spalten erfüllen muss.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey*2 = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |    15 |  1665 |  1470   (1)| 00:00:18 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| ORDERS     |    15 |  1665 |  1470   (1)| 00:00:18 |
|*  2 |   INDEX RANGE SCAN          | O_CLERK_IX |  1500 |       |     8   (0)| 00:00:01 |
------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"*2=44444)
   2 - access("O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 111111 AND 222222;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------------------------
| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |               | 27780 |  3011K|   932   (1)| 00:00:12 |
|   1 |  TABLE ACCESS BY INDEX ROWID| ORDERS        | 27780 |  3011K|   932   (1)| 00:00:12 |
|*  2 |   INDEX RANGE SCAN          | O_ORDERKEY_IX | 27780 |       |    68   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("O_ORDERKEY">=111111 AND "O_ORDERKEY"<=222222)
\end{lstlisting}
\textbf{Reflexion} \newline
Der Optimizer wandelt den BETWEEN-Befehl in zwei mathematische Operationen um.
Hier wird der Index Range Scan ausgeführt, weil der Range klein genug gewählt wurde, dass sich die Anzahl IO-Zugriffe noch lohnt.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 111111 AND 222222123;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1472K|   155M|  6617   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |  1472K|   155M|  6617   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY">=111111 AND "O_ORDERKEY"<=222222123)
\end{lstlisting}
\textbf{Reflexion} \newline
Hier wurde nun ein Full Table Scan ausgeführt, weil der Range gross genug gewählt wurde, dass es wegen der vielen IO-Zugriffe nicht mehr lohnt.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 44444 AND 55555
AND o_clerk BETWEEN 'Clerk#000000130' AND 'Clerk#000000139';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplanSmall]
--------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |               |     6 |   666 |    27  (12)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID     | ORDERS        |     6 |   666 |    27  (12)| 00:00:01 |
|   2 |   BITMAP CONVERSION TO ROWIDS    |               |       |       |            |          |
|   3 |    BITMAP AND                    |               |       |       |            |          |
|   4 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|   5 |      SORT ORDER BY               |               |       |       |            |          |
|*  6 |       INDEX RANGE SCAN           | O_ORDERKEY_IX |  2780 |       |     9   (0)| 00:00:01 |
|   7 |     BITMAP CONVERSION FROM ROWIDS|               |       |       |            |          |
|   8 |      SORT ORDER BY               |               |       |       |            |          |
|*  9 |       INDEX RANGE SCAN           | O_CLERK_IX    |  2780 |       |    14   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   6 - access("O_ORDERKEY">=44444 AND "O_ORDERKEY"<=55555)
   9 - access("O_CLERK">='Clerk#000000130' AND "O_CLERK"<='Clerk#000000139')
\end{lstlisting}
\textbf{Reflexion} \newline


\subsection{Join}

\section{Quiz}

\section{Deep Left Join}
Verwendetes Statement, um ein initiales Deep Left Join zu erzeugen:
\begin{lstlisting}[style=sql]
SELECT *
FROM orders, lineitems, partsupps, parts
WHERE orders.o_orderkey = lineitems.l_orderkey
AND lineitems.l_suppkey = partsupps.ps_suppkey
AND partsupps.ps_partkey = parts.p_partkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation            | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |           |   482M|   229G|       |  9176K  (1)| 30:35:13 |
|*  1 |  HASH JOIN           |           |   482M|   229G|    27M|  9176K  (1)| 30:35:13 |
|   2 |   TABLE ACCESS FULL  | PARTS     |   200K|    25M|       |  1051   (1)| 00:00:13 |
|*  3 |   HASH JOIN          |           |   486M|   171G|   118M|   168K  (2)| 00:33:39 |
|   4 |    TABLE ACCESS FULL | PARTSUPPS |   800K|   109M|       |  4526   (1)| 00:00:55 |
|*  5 |    HASH JOIN         |           |  6086K|  1369M|   175M| 84027   (1)| 00:16:49 |
|   6 |     TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
|   7 |     TABLE ACCESS FULL| LINEITEMS |  6001K|   715M|       | 29752   (1)| 00:05:58 |
------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("PARTSUPPS"."PS_PARTKEY"="PARTS"."P_PARTKEY")
   3 - access("LINEITEMS"."L_SUPPKEY"="PARTSUPPS"."PS_SUPPKEY")
   5 - access("ORDERS"."O_ORDERKEY"="LINEITEMS"."L_ORDERKEY")
\end{lstlisting}
Modifiziertes Statement, um ein Bushy Tree zu erzeugen:
\begin{lstlisting}[style=sql]
SELECT  *
FROM 
(
SELECT /*+ no_merge */ *
FROM orders, lineitems
WHERE orders.o_orderkey = lineitems.l_orderkey
)
,
(
SELECT /*+ no_merge */ *
FROM partsupps, parts
WHERE partsupps.ps_partkey = parts.p_partkey
)
WHERE l_suppkey = ps_suppkey;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
------------------------------------------------------------------------------------------
| Id  | Operation            | Name      | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |           |   482M|   286G|       |   211K  (2)| 00:42:23 |
|*  1 |  HASH JOIN           |           |   482M|   286G|   234M|   211K  (2)| 00:42:23 |
|   2 |   VIEW               |           |   792K|   225M|       | 12812   (1)| 00:02:34 |
|*  3 |    HASH JOIN         |           |   792K|   207M|    27M| 12812   (1)| 00:02:34 |
|   4 |     TABLE ACCESS FULL| PARTS     |   200K|    25M|       |  1051   (1)| 00:00:13 |
|   5 |     TABLE ACCESS FULL| PARTSUPPS |   800K|   109M|       |  4526   (1)| 00:00:55 |
|   6 |   VIEW               |           |  6086K|  1967M|       | 84027   (1)| 00:16:49 |
|*  7 |    HASH JOIN         |           |  6086K|  1369M|   175M| 84027   (1)| 00:16:49 |
|   8 |     TABLE ACCESS FULL| ORDERS    |  1500K|   158M|       |  6610   (1)| 00:01:20 |
|   9 |     TABLE ACCESS FULL| LINEITEMS |  6001K|   715M|       | 29752   (1)| 00:05:58 |
------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("L_SUPPKEY"="PS_SUPPKEY")
   3 - access("PARTSUPPS"."PS_PARTKEY"="PARTS"."P_PARTKEY")
   7 - access("ORDERS"."O_ORDERKEY"="LINEITEMS"."L_ORDERKEY")
\end{lstlisting}
\textbf{Reflexion} \newline

\section{Eigene SQL-Anfragen}

% Inhalt Ende 
\end{document} 