\documentclass[10pt]{article}

%Math
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{stmaryrd} %f\UTF{00FC}r Blitz!

%PageStyle
\usepackage[ngerman]{babel} % deutsche Silbentrennung
\usepackage[utf8]{inputenc} 
\usepackage{fancyhdr, graphicx}
\usepackage[scaled=0.92]{helvet}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage[a4paper,top=2cm]{geometry}
\setlength{\textwidth}{17cm}
\setlength{\oddsidemargin}{-0.5cm}

% Shortcommands
\newcommand{\Bold}[1]{\textbf{#1}} %Boldface
\newcommand{\Kursiv}[1]{\textit{#1}} %Italic
\newcommand{\T}[1]{\text{#1}} %Textmode
\newcommand{\Nicht}[1]{\T{\sout{$ #1 $}}} %Streicht Shit durch

%Arrows
\newcommand{\lra}{\leftrightarrow} 
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lral}{\longleftrightarrow}
\newcommand{\ral}{\longrightarrow}
\newcommand{\lal}{\longleftarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\Lral}{\Longleftrightarrow}
\newcommand{\Ral}{\Longrightarrow}
\newcommand{\Lal}{\Longleftarrow}

% Code listenings
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstdefinestyle{sql}{
 language=SQL,
 basicstyle=\footnotesize\ttfamily, % Standardschrift
 backgroundcolor=\color[RGB]{230,230,230}, % Hintergrundfarbe
 numbers=left,               % Ort der Zeilennummern
 numberstyle=\tiny,          % Stil der Zeilennummern
 stepnumber=1,               % Abstand zwischen den Zeilennummern
 numbersep=5pt,              % Abstand der Nummern zum Text
 tabsize=2,                  % Groesse von Tabs
 extendedchars=true,         %
 breaklines=true,            % Zeilen werden Umgebrochen
 frame=trbl,                 % Rahmen
 stringstyle=\color[RGB]{42,0,255} \ttfamily, % Farbe der String
 keywordstyle=\color[RGB]{127,0,85} \ttfamily, % Farbe der Keywords
 commentstyle=\color[RGB]{63,127,95} \ttfamily, % Farbe des Kommentars
 showspaces=false,           % Leerzeichen anzeigen ?
 showtabs=false,             % Tabs anzeigen ?
 xleftmargin=17pt,
 framexleftmargin=17pt,
 framexrightmargin=5pt,
 framexbottommargin=5pt,
 framextopmargin=5pt,
 showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
}

\lstdefinestyle{queryexecutionplan}{
 basicstyle=\footnotesize\ttfamily, % Standardschrift
 backgroundcolor=\color[RGB]{240,255,240}, % Hintergrundfarbe
 frame=trbl,                 % Rahmen
}

%Config
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{15.2pt}

%Metadata
\fancyfoot[C]{}
\title{
	\vspace{4cm}
	\huge{Datenbank-Architektur für Fortgeschrittene}\\
	\vspace{0.2cm}
	\Large{Ausarbeitung 1: Anfrageverarbeitung}\\
}
\author{Thomas Baumann / Egemen Kaba}
\date{01.05.2013}

% hier beginnt das Dokument
\begin{document}

% Titelbild
\maketitle
\thispagestyle{fancy}

\newpage

% Inhaltsverzeichnis
\pagenumbering{Roman}
\tableofcontents	  	


\newpage
\setcounter{page}{1}
\pagenumbering{arabic}

% Inhalt Start

\section{Einleitung}
\subsection{Sonderzächön}
sind mägö cöäl! Hallo "Max" und "Moritz"!
\section{Vorbereitung}
\subsection{Einrichten Datenbasis}
\begin{lstlisting}[style=sql]
CREATE TABLE regions
AS SELECT *
  FROM dbarc00.regions;
  
CREATE TABLE nations
AS SELECT *
  FROM dbarc00.nations;

CREATE TABLE parts
AS SELECT *
  FROM dbarc00.parts;
  
CREATE TABLE customers
AS SELECT *
  FROM dbarc00.customers;

CREATE TABLE suppliers
AS SELECT *
  FROM dbarc00.suppliers;

CREATE TABLE orders
AS SELECT *
  FROM dbarc00.orders;

CREATE TABLE partsupps
AS SELECT *
  FROM dbarc00.partsupps;

CREATE TABLE lineitems
AS SELECT *
  FROM dbarc00.lineitems;
\end{lstlisting}

\section{Ausführungsplan}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM parts;

SELECT plan_table_output
FROM TABLE(DBMS_XPLAN.DISPLAY('plan_table',null,'serial'));
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |   190K|    26M|  1051   (1)| 00:00:13 |
|   1 |  TABLE ACCESS FULL| PARTS |   190K|    26M|  1051   (1)| 00:00:13 |
---------------------------------------------------------------------------
\end{lstlisting}
Die Tabelle zeigt die einzelnen Schritte des Ausführungsplanes, welche der 
Optimizer erstellt hat, mit den jeweilig zurückgegebenen Zeilen, deren Grösse 
und die Kosten für die Teilschritte. Die Kosten sind immer aufsummiert von 
unten nach oben. Sie werden berechnet aus Disk I/O Zugriffen, CPU Belastung 
und Hauptspeicher verbrauch. Der CPU Verbrauch wird immer gerundet, womit 
wir die Differenzen nicht genau sehen.
Man kann sich den Ausführungsplan als Baum vorstellen. Die Einrückungen 
stellen die Knotentiefe dar.

Für die nächsten Aufgaben verwenden wir das obenstehende Statement. Wir 
haben jeweils das Query ausgetauscht um den Ausführungsplan zu erhalten.

\section{Versuche ohne Index}
\subsection{Projektion}
\textbf{Statement}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders;
\end{lstlisting}
\textbf{Ausführungsplan}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------                                                                                                                                                                                                                                 
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |                                                                                                                                                                                                                                 
----------------------------------------------------------------------------                                                                                                                                                                                                                                 
|   0 | SELECT STATEMENT  |        |  1579K|   209M|  6612   (1)| 00:01:20 |                                                                                                                                                                                                                                 
|   1 |  TABLE ACCESS FULL| ORDERS |  1579K|   209M|  6612   (1)| 00:01:20 |                                                                                                                                                                                                                                 
---------------------------------------------------------------------------- 
\end{lstlisting}   
\textbf{Reflexion} \newline
Da alle Zeilen und Spalten der Tabelle ausgelesen werden müssen wird hier ein
Full Table Scan durchgeführt. Aus der Statistik geht hervor, dass diese Tabelle
1579K Zeilen umfasst, 209MB gross ist und ein Full Table Scan 6612 CPU-Indexpunkte
beansprucht.

\textbf{Statement}
\begin{lstlisting}[style=sql]
SELECT o_clerk
FROM orders;
\end{lstlisting}
\textbf{Ausführungsplan}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------                                                                                                                                                                                                                                 
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |                                                                                                                                                                                                                                 
----------------------------------------------------------------------------                                                                                                                                                                                                                                 
|   0 | SELECT STATEMENT  |        |  1579K|    25M|  6608   (1)| 00:01:20 |                                                                                                                                                                                                                                 
|   1 |  TABLE ACCESS FULL| ORDERS |  1579K|    25M|  6608   (1)| 00:01:20 |                                                                                                                                                                                                                                 
---------------------------------------------------------------------------- 
\end{lstlisting}   
\textbf{Reflexion} \newline
Es werden wiederum alle Zeile, jedoch nicht alle Spalten ausgelesen.
Exakt läuft es so ab, dass zuerst die ganze Tabelle gelesen wird und danach die nicht
benötigten Spalten herausgefiltert werden.
Das verringert die Anzahl Daten, die gespeichert werden müssen, drastisch von 209MB auf 25MB.
Zudem ist die benötigte CPU-Leistung minimal weniger, aufgrund der Reduktion des
zu verwaltenden Speichers.

\textbf{Statement}
\begin{lstlisting}[style=sql]
SELECT DISTINCT o_clerk
FROM orders;
\end{lstlisting}
\textbf{Ausführungsplan}
\begin{lstlisting}[style=queryexecutionplan]
-------------------------------------------------------------------------------------                                                                                                                                                                                                                        
| Id  | Operation          | Name   | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |                                                                                                                                                                                                                        
-------------------------------------------------------------------------------------                                                                                                                                                                                                                        
|   0 | SELECT STATEMENT   |        |  1579K|    25M|       | 15333   (1)| 00:03:04 |                                                                                                                                                                                                                        
|   1 |  HASH UNIQUE       |        |  1579K|    25M|    36M| 15333   (1)| 00:03:04 |                                                                                                                                                                                                                        
|   2 |   TABLE ACCESS FULL| ORDERS |  1579K|    25M|       |  6608   (1)| 00:01:20 |                                                                                                                                                                                                                        
-------------------------------------------------------------------------------------
\end{lstlisting} 
\textbf{Reflexion} \newline
Wie beim vorherigen Befehl werden alle Zeilen einer bestimmten Spalte ausgelesen,
was wiederum einen Zugriff auf die gesamte Tabelle nötig macht.
Zusätzlich zu diesem Aufwand müssen vorangehend alle doppelten Einträge herausgefiltert werden,
was die massiv angestiegenen CPU-Kosten bei Id 0 und 1 erklärt.
Die zusätzliche Operation mit der Id 1 dient dazu, die doppelten Werte herauszufiltern.
Für die Speicherung von Zwischenresultaten wird dabei temporärer Speicher beansprucht.

\subsection{Selektion}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6603   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6603   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444)
\end{lstlisting}
Es wird nur ein Tupel selektioniert, jedoch ist die Spalte „id“ nicht indexiert, 
somit weiss die Datenbank nicht, wo genau sich die Datensätze auf der Disk 
befinden. Da die „id“ nicht eindeutig ist, kann beim ersten gefundenen Datensatz 
nicht abgebrochen werden. Daraus resultiert wieder ein Full Table Scan. Die 
Kosten sind dank der Bedingung ein wenig kleiner, da viel weniger Hauptspeicher 
benötigt wird.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 OR o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6631   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6631   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444 OR "O_CLERK"='Clerk#000000286')
\end{lstlisting}
Die Kosten sind hier durch den zusätzlichen Vergleich, welcher eine höhere 
CPU Belastung verursacht, minimal gestiegen.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   158 | 21962 |  6612   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   158 | 21962 |  6612   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
Die CPU-Kosten sind hier wieder kleiner, da aufgrund der AND-Verknüpfung die 
zweite Bedingung nur überprüft werden muss, wenn die erste Bedingung erfüllt ist.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey*2 = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   158 | 21962 |  6616   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   158 | 21962 |  6616   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"*2=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
Wenn man das Statement anschaut sollte die CPU Belastung höher sein, da eine 
zusätzliche Operation pro Tupel notwendig ist $(o_orderkey * 2)$. Die Kosten 
sind jedoch genau gleich wie beim vorherigen Statement. Wir vermuten, dass 
dies optimiert wird zu:
\begin{lstlisting}[style=sql]
o_orderkey = 22222 AND o_clerk = 'Clerk#000000286'
\end{lstlisting}
Dadurch würde die Operation nur einmal ausgeführt werden.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 111111 AND 222222;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6603   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6603   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY">=111111 AND "O_ORDERKEY"<=222222)
\end{lstlisting}
TODO CHECK
Die Kosten sind kleiner als oben, obwohl laut Ausführungsplan die CPU Belastung 
gleich ist und bei beiden ein Full Table Scan durchgeführt werden muss. Der 
Hauptspeicher Verbrauch ist sogar grösser, woraus höhere Kosten resultieren 
müssten. Diese Differenz kommt durch die Rundung der CPU Angabe. Wir habe mit 
folgendem Statement den CPU Verbrauch genauer angezeigt:
$SELECT
CPU_COST
FROM
PLAN_TABLE;$
Dadurch haben wir festgestellt, dass der CPU Verbrauch tatsächlich kleiner ist 
als beim obigen Statement. Dies kommt daher, weil nur die Spalte „id“ 
verglichen werden muss anstatt „id“ und „provider“.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 44444 AND 55555
AND o_clerk BETWEEN 'Clerk#000000130' AND 'Clerk#000000139';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |    10 |  1390 |  6613   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |    10 |  1390 |  6613   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY">=44444 AND "O_ORDERKEY"<=55555 AND 
              "O_CLERK">='Clerk#000000130' AND "O_CLERK"<='Clerk#000000139')
\end{lstlisting}
TODO

\subsection{Join}
\textbf{Statement}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders, customers
WHERE o_custkey = c_custkey
AND o_orderkey < 100;
\end{lstlisting}
\textbf{Ausführungsplan}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------                                                                                                                                                                                                                             
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |                                                                                                                                                                                                                             
--------------------------------------------------------------------------------                                                                                                                                                                                                                             
|   0 | SELECT STATEMENT   |           |   267 | 80901 |  7555   (1)| 00:01:31 |                                                                                                                                                                                                                             
|*  1 |  HASH JOIN         |           |   267 | 80901 |  7555   (1)| 00:01:31 |                                                                                                                                                                                                                             
|*  2 |   TABLE ACCESS FULL| ORDERS    |   267 | 37113 |  6603   (1)| 00:01:20 |                                                                                                                                                                                                                             
|   3 |   TABLE ACCESS FULL| CUSTOMERS |   131K|    20M|   951   (1)| 00:00:12 |                                                                                                                                                                                                                             
-------------------------------------------------------------------------------- 
\end{lstlisting}  
\textbf{Varianten}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE o_orderkey < 100
AND c_custkey = o_custkey;
\end{lstlisting}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE c_custkey = o_custkey
AND o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE o_custkey = c_custkey
AND o_orderkey < 100;
\end{lstlisting}
\textbf{Reflexion} \newline
Der Optimizer wählt bei allen Varianten automatisch die Perfomanteste aus. Somit lautet die Antwort auf die Frage: Nein.
Im Folgenden werden einige Gründe aufgeführt:
Es wird ein Fremdschlüssel von orders und der Primärschlüssel von customers verglichen.
Dadurch können in beiden Tabellen nicht benötigte Tuppel vorab herausgefiltert werden.
Dies hat den Vorteil, dass weniger Speicher und CPU für weitere Operationen benötigt werden.
Danach werden die restlichen Tuppel der Tabelle orders mit der zweiten Bedingung herausgefiltert.
Wenn nun die minimalst mögliche Anzahl Tuppel erreicht worden sind, wird auf die Tabelle
customers zugegriffen und mit der Tabelle orders gejoint.

% Inhalt Ende 
\end{document} 