\documentclass[10pt]{article}

%Math
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{stmaryrd} %f\UTF{00FC}r Blitz!

%PageStyle
\usepackage[ngerman]{babel} % deutsche Silbentrennung
\usepackage[utf8]{inputenc} 
\usepackage{fancyhdr, graphicx}
\usepackage[scaled=0.92]{helvet}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage[a4paper,top=2cm]{geometry}
\setlength{\textwidth}{17cm}
\setlength{\oddsidemargin}{-0.5cm}

% Shortcommands
\newcommand{\Bold}[1]{\textbf{#1}} %Boldface
\newcommand{\Kursiv}[1]{\textit{#1}} %Italic
\newcommand{\T}[1]{\text{#1}} %Textmode
\newcommand{\Nicht}[1]{\T{\sout{$ #1 $}}} %Streicht Shit durch

%Arrows
\newcommand{\lra}{\leftrightarrow} 
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lral}{\longleftrightarrow}
\newcommand{\ral}{\longrightarrow}
\newcommand{\lal}{\longleftarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\Lral}{\Longleftrightarrow}
\newcommand{\Ral}{\Longrightarrow}
\newcommand{\Lal}{\Longleftarrow}

% Code listenings
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{white}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white,font=bf}


\lstdefinestyle{sqlNoTitle}{
   language=SQL,
   basicstyle=\footnotesize\ttfamily, % Standardschrift
   backgroundcolor=\color[RGB]{230,230,230}, % Hintergrundfarbe
   numbers=left,               % Ort der Zeilennummern
   numberstyle=\tiny,          % Stil der Zeilennummern
   stepnumber=1,               % Abstand zwischen den Zeilennummern
   numbersep=5pt,              % Abstand der Nummern zum Text
   tabsize=2,                  % Groesse von Tabs
   extendedchars=true,         %
   breaklines=true,            % Zeilen werden Umgebrochen
   frame=trbl,                 % Rahmen
   stringstyle=\color[RGB]{42,0,255} \ttfamily, % Farbe der String
   keywordstyle=\color[RGB]{127,0,85} \ttfamily, % Farbe der Keywords
   commentstyle=\color[RGB]{63,127,95} \ttfamily, % Farbe des Kommentars
   showspaces=false,           % Leerzeichen anzeigen ?
   showtabs=false,             % Tabs anzeigen ?
   xleftmargin=17pt,
   framexleftmargin=17pt,
   framexrightmargin=5pt,
   framexbottommargin=5pt,
   framextopmargin=5pt,
   showstringspaces=false,     % Leerzeichen in Strings anzeigen ?
}


\lstdefinestyle{sql}{
   style=sqlNoTitle,
   title=SQL-Query
}

\lstdefinestyle{queryexecutionplan}{
  basicstyle=\footnotesize\ttfamily, % Standardschrift
  backgroundcolor=\color[RGB]{240,255,240}, % Hintergrundfarbe
  frame=trbl,                 % Rahmen
  title=Ausführungsplan
}

%Config
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{15.2pt}

%Metadata
\fancyfoot[C]{}
\title{
	\vspace{4cm}
	\huge{Datenbank-Architektur für Fortgeschrittene}\\
	\vspace{0.2cm}
	\Large{Ausarbeitung 1: Anfrageverarbeitung}\\
}
\author{Thomas Baumann / Egemen Kaba}
\date{01.05.2013}

% hier beginnt das Dokument
\begin{document}

% Titelbild
\maketitle
\thispagestyle{fancy}

\newpage

% Inhaltsverzeichnis
\pagenumbering{Roman}
\tableofcontents	  	


\newpage
\setcounter{page}{1}
\pagenumbering{arabic}

% Inhalt Start

\section{Einleitung}
\subsection{Sonderzächön}
sind mägö cöäl! Hallo "Max" und "Moritz"!
\section{Vorbereitung}
\subsection{Einrichten Datenbasis}
\begin{lstlisting}[style=sql]
CREATE TABLE regions
AS SELECT *
  FROM dbarc00.regions;
  
CREATE TABLE nations
AS SELECT *
  FROM dbarc00.nations;

CREATE TABLE parts
AS SELECT *
  FROM dbarc00.parts;
  
CREATE TABLE customers
AS SELECT *
  FROM dbarc00.customers;

CREATE TABLE suppliers
AS SELECT *
  FROM dbarc00.suppliers;

CREATE TABLE orders
AS SELECT *
  FROM dbarc00.orders;

CREATE TABLE partsupps
AS SELECT *
  FROM dbarc00.partsupps;

CREATE TABLE lineitems
AS SELECT *
  FROM dbarc00.lineitems;
\end{lstlisting}

\section{Ausführungsplan}
\begin{lstlisting}[style=sql]
EXPLAIN PLAN FOR
SELECT *
FROM parts;

SELECT plan_table_output
FROM TABLE(DBMS_XPLAN.DISPLAY('plan_table',null,'serial'));
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |   190K|    26M|  1051   (1)| 00:00:13 |
|   1 |  TABLE ACCESS FULL| PARTS |   190K|    26M|  1051   (1)| 00:00:13 |
---------------------------------------------------------------------------
\end{lstlisting}
Die Tabelle zeigt die einzelnen Schritte des Ausführungsplanes, welche der 
Optimizer erstellt hat, mit den jeweilig zurückgegebenen Zeilen, deren Grösse 
und die Kosten für die Teilschritte. Die Kosten sind immer aufsummiert von 
unten nach oben. Sie werden berechnet aus Disk I/O Zugriffen, CPU Belastung 
und Hauptspeicher verbrauch. Der CPU Verbrauch wird immer gerundet, womit 
wir die Differenzen nicht genau sehen.
Man kann sich den Ausführungsplan als Baum vorstellen. Die Einrückungen 
stellen die Knotentiefe dar.

Für die nächsten Aufgaben verwenden wir das obenstehende Statement. Wir 
haben jeweils das Query ausgetauscht um den Ausführungsplan zu erhalten.

\section{Versuche ohne Index}
\subsection{Projektion}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1579K|   209M|  6612   (1)| 00:01:20 |
|   1 |  TABLE ACCESS FULL| ORDERS |  1579K|   209M|  6612   (1)| 00:01:20 |
---------------------------------------------------------------------------- 
\end{lstlisting}   
\textbf{Reflexion} \newline
Da alle Zeilen und Spalten der Tabelle ausgelesen werden müssen wird hier ein
Full Table Scan durchgeführt. Aus der Statistik geht hervor, dass diese Tabelle
1579K Zeilen umfasst, 209MB gross ist und ein Full Table Scan 6612 CPU-Indexpunkte
beansprucht.

\begin{lstlisting}[style=sql]
SELECT o_clerk
FROM orders;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |  1579K|    25M|  6608   (1)| 00:01:20 |
|   1 |  TABLE ACCESS FULL| ORDERS |  1579K|    25M|  6608   (1)| 00:01:20 |
---------------------------------------------------------------------------- 
\end{lstlisting}   
\textbf{Reflexion} \newline
Es werden wiederum alle Zeile, jedoch nicht alle Spalten ausgelesen.
Exakt läuft es so ab, dass zuerst die ganze Tabelle gelesen wird und danach die nicht
benötigten Spalten herausgefiltert werden.
Das verringert die Anzahl Daten, die gespeichert werden müssen, drastisch von 209MB auf 25MB.
Zudem ist die benötigte CPU-Leistung minimal weniger, aufgrund der Reduktion des
zu verwaltenden Speichers.

\begin{lstlisting}[style=sql]
SELECT DISTINCT o_clerk
FROM orders;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
-------------------------------------------------------------------------------------
| Id  | Operation          | Name   | Rows  | Bytes |TempSpc| Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |        |  1579K|    25M|       | 15333   (1)| 00:03:04 |
|   1 |  HASH UNIQUE       |        |  1579K|    25M|    36M| 15333   (1)| 00:03:04 |
|   2 |   TABLE ACCESS FULL| ORDERS |  1579K|    25M|       |  6608   (1)| 00:01:20 |
-------------------------------------------------------------------------------------
\end{lstlisting} 
\textbf{Reflexion} \newline
Wie beim vorherigen Befehl werden alle Zeilen einer bestimmten Spalte ausgelesen,
was wiederum einen Zugriff auf die gesamte Tabelle nötig macht.
Zusätzlich zu diesem Aufwand müssen vorangehend alle doppelten Einträge herausgefiltert werden,
was die massiv angestiegenen CPU-Kosten bei Id 0 und 1 erklärt.
Die zusätzliche Operation mit der Id 1 dient dazu, die doppelten Werte herauszufiltern.
Für die Speicherung von Zwischenresultaten wird dabei temporärer Speicher beansprucht.

\subsection{Selektion}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6603   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6603   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444)
\end{lstlisting}
\textbf{Reflexion} \newline
Es soll nur ein Tupel ausgewählt werden (Spalte ist Primary Key), da jedoch 
kein index besteht, ist nicht bekannt, wo der Eintrag liegt und zusätzlich 
kann nach dem ersten Fund nicht abgebrochen werden. Deshalb muss wieder ein 
Full Table Scan durchgeführt werden. Durch die Bedingung wird viel weniger 
Hauptspeicher benötigt.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 OR o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6631   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6631   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444 OR "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Im Vergleich zum vorherigen Query sind nur die Kosten minimal gestiegen, dies 
ist auf die zweite Bedingung zurück zu führen.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   158 | 21962 |  6612   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   158 | 21962 |  6612   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Durch die AND-verknüpfung muss die zweite Bedingung nur überprüft werden, wenn 
die Erste erfüllt ist. So sind alle Werte, ausser die Zeit gesunken.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey*2 = 44444 AND o_clerk = 'Clerk#000000286';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   158 | 21962 |  6616   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   158 | 21962 |  6616   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY"*2=44444 AND "O_CLERK"='Clerk#000000286')
\end{lstlisting}
\textbf{Reflexion} \newline
Die Werte sind alle genau gleich, wie beim vorherigen Query, obwohl eigentlich 
eine zusätzliche Operation pro Zeile notwendig ist ($o\_orderkey*2$). Wir 
vermuten, dass dieses Query vor der Abfrage optimiert wird, besser gesagt, die
Berechnung wird vereinfacht, so muss nur eine Operation ausgeführt werden:
\begin{lstlisting}[style=sqlNoTitle]
o_orderkey = 22222 AND o_clerk = 'Clerk#000000286'
\end{lstlisting}

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 111111 AND 222222;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |   267 | 37113 |  6603   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |   267 | 37113 |  6603   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY">=111111 AND "O_ORDERKEY"<=222222)
\end{lstlisting}
\textbf{Reflexion} \newline
Die Selektion 
\begin{lstlisting}[style=sqlNoTitle]
column BETWEEN x AND y 
\end{lstlisting}
wird durch folgendes 
\begin{lstlisting}[style=sqlNoTitle]
column >= x AND column <= y 
\end{lstlisting}
ersetzt. Im Vergleich zum Vorherigen, sind die Anzahl Zeilen und die 
Speicherbenutzung gestiegen, dies weil mehr Tupel selektiert werden. Hingegen 
sind die Kosten gesunken, dies ist aus unserer Sicht dadurch zu Begründen, da 
bei beiden Vergleichen, die gleiche Spalte verwendet wird.

\begin{lstlisting}[style=sql]
SELECT *
FROM orders
WHERE o_orderkey BETWEEN 44444 AND 55555
AND o_clerk BETWEEN 'Clerk#000000130' AND 'Clerk#000000139';
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |    10 |  1390 |  6613   (1)| 00:01:20 |
|*  1 |  TABLE ACCESS FULL| ORDERS |    10 |  1390 |  6613   (1)| 00:01:20 |
----------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("O_ORDERKEY">=44444 AND "O_ORDERKEY"<=55555 AND 
              "O_CLERK">='Clerk#000000130' AND "O_CLERK"<='Clerk#000000139')
\end{lstlisting}
\textbf{Reflexion} \newline
Auch hier wurden die BETWEEN wieder mit grösser gleich und kleiner gleich ersetzt. 
Die Resultierende Anzahl Tupel und der benötigte Speicher sind nochmals gesunken. 
Wohin gegen die Kosten gestiegen sind, da bis zu vier Vergleiche notwendig sind.

\subsection{Join}
\begin{lstlisting}[style=sql]
SELECT *
FROM orders, customers
WHERE o_custkey = c_custkey
AND o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=queryexecutionplan]
--------------------------------------------------------------------------------                                                                                                                                                                                                                             
| Id  | Operation          | Name      | Rows  | Bytes | Cost (%CPU)| Time     |                                                                                                                                                                                                                             
--------------------------------------------------------------------------------                                                                                                                                                                                                                             
|   0 | SELECT STATEMENT   |           |   267 | 80901 |  7555   (1)| 00:01:31 |                                                                                                                                                                                                                             
|*  1 |  HASH JOIN         |           |   267 | 80901 |  7555   (1)| 00:01:31 |                                                                                                                                                                                                                             
|*  2 |   TABLE ACCESS FULL| ORDERS    |   267 | 37113 |  6603   (1)| 00:01:20 |                                                                                                                                                                                                                             
|   3 |   TABLE ACCESS FULL| CUSTOMERS |   131K|    20M|   951   (1)| 00:00:12 |                                                                                                                                                                                                                             
-------------------------------------------------------------------------------- 
\end{lstlisting}  
\textbf{Varianten}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE o_orderkey < 100
AND c_custkey = o_custkey;
\end{lstlisting}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE c_custkey = o_custkey
AND o_orderkey < 100;
\end{lstlisting}
\begin{lstlisting}[style=sql]
SELECT *
FROM customers, orders
WHERE o_custkey = c_custkey
AND o_orderkey < 100;
\end{lstlisting}
\textbf{Reflexion} \newline
Der Optimizer wählt bei allen Varianten automatisch die Perfomanteste aus. Somit lautet die Antwort auf die Frage: Nein.
Im Folgenden werden einige Gründe aufgeführt:
Es wird ein Fremdschlüssel von orders und der Primärschlüssel von customers verglichen.
Dadurch können in beiden Tabellen nicht benötigte Tuppel vorab herausgefiltert werden.
Dies hat den Vorteil, dass weniger Speicher und CPU für weitere Operationen benötigt werden.
Danach werden die restlichen Tuppel der Tabelle orders mit der zweiten Bedingung herausgefiltert.
Wenn nun die minimalst mögliche Anzahl Tuppel erreicht worden sind, wird auf die Tabelle
customers zugegriffen und mit der Tabelle orders gejoint.

% Inhalt Ende 
\end{document} 